/*
1024. 科学计数法 (20)
时间限制：100 ms  内存限制：65536 kB  代码长度限制：8000 B

题目描述：
科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，
其满足正则表达式[+-][1-9]"."[0-9]+E[+-][0-9]+，即数字的整数部分只有1位，
小数部分至少有1位，该数字及其指数部分的正负号即使对正数也必定明确给出。
现以科学计数法的格式给出实数A，请编写程序按普通数字表示法输出A，
并保证所有有效位都被保留。

输入格式：
每个输入包含1个测试用例，即一个以科学计数法表示的实数A。
该数字的存储长度不超过9999字节，且其指数的绝对值不超过9999。
输出格式：
对每个测试用例，在一行中按普通数字表示法输出A，
并保证所有有效位都被保留，包括末尾的0。
输入样例1：+1.23400E-03
输出样例1：0.00123400
输入样例2：-1.2E+10
输出样例2：-12000000000
 */



#include <cstdio>
#include <cstring> // strlen函数头文件 

const int maxn = 10010; // 长度不超10000Byte，char为1Byte 
char str[maxn]; // 科学计数法表示的实数 
char exp[maxn]; // 指数 

int main()
{
	gets(str); // 输入 
	if (str[0] == '-') printf("-"); // 负数输出负号，正数不输出 
	
	int i = 0, pos; // pos为E所在位置 
	while (str[i] != 'E') i++; // 查询E所在位置 
	pos = i;
	
	int len = strlen(str), j = 0; // len为字符串长度 
	for (i++; i < len; i++) { // 复制指数字符串 
		exp[j++] = str[i];
	}
	
	int e = 0, p = 1; // e为整型指数 
	for (i = j - 1; i >= 1; i--) { // 将字符型指数转换成整型指数 
		e += (exp[i] - '0') * p;
		p *= 10;
	}
	
	if(e == 0) { // 指数为0 
		for (i = 1; i < pos; i++) {
			printf("%c", str[i]);
		}
	} else { // 指数不为0 
		if (exp[0] == '-') { // 指数为负 
			printf("0."); // 先输出前两位 
			
			i = e - 1; 
			while (i--) printf("0"); // 剩余需要输出e-1个0 
			
			for (i = 1; i < pos; i++) { // 输出E前面的数，不带小数点 
				if (str[i] == '.') continue;
				printf("%c", str[i]);
			}
		}
		
		if(exp[0] == '+') { // 指数为正 
			// 小数点和i之间共i-2位，比指数e小，则转换后的实数无小数点
			i = pos - 1; // i为E前一位 
			if ((i - 2) <= e) {  
				for (j = 1; j <= i; j++) { // 输出i在内之前的数，不带小数点 
					if (str[j] == '.') continue;
					printf("%c", str[j]);
				}
				
				int count = e - (i - 2); // 剩余待输出0的个数 
				while (count--) printf("0"); // 输出count个0 
			} else { // 大于指数e，则转换后的实数有小数点
				// 输出e+2在内之前的数，不带小数点 
				for (j = 1; j <= e + 2; j++) { 
					if (str[j] == '.') continue;
					printf("%c", str[j]);
				}
				
				printf("."); // 输出小数点 
				
				for ( ; j <= i; j++) { // 输出小数点后至i之间的数 
					printf("%c", str[j]);
				}
			}
		}
	} 
	return 0;
}
